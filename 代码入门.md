# 代码入门
## 数组相关
### 整数二分
>考虑好边界情况
```c
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
### 前缀和
>相当于数学的S~n~
一维形式
```c
#include <vector>

class NumArray {
    // 前缀和数组
    std::vector<int> preSum;

    // 输入一个数组，构造前缀和
    public:
    NumArray(std::vector<int>& nums) {
        preSum.resize(nums.size() + 1);//.resize函数中,若重新分配的大小大于原来的大小,新开辟的值会被赋成0,这里presum是空数组,全部都为0
        // 计算 nums 的累加和
        for (int i = 1; i < preSum.size(); i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];//i从1开始是因为左边界的边界效应,preSum[right + 1] - preSum[left]
        }
    }

    // 查询闭区间 [left, right] 的累加和
    int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
};
```
二维形式
```c
public:
    // 构造函数：根据输入矩阵构建前缀和数组
    NumMatrix(std::vector<std::vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();//matrix.size()是矩阵的行数,n为矩阵的列数
        // 处理空矩阵情况
        if (m == 0 || n == 0) return;
        
        // 初始化前缀和数组：尺寸为(m+1) x (n+1)，所有元素初始化为0
        preSum.resize(m + 1, std::vector<int>(n + 1, 0));//直接初始化std::vector<std::vector<int>> presum(m+1,std::vector<int>(n+1,0));
        
        // 构建二维前缀和数组
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                /* 核心递推公式：
                 * preSum[i][j] = 上方矩形和 + 左边矩形和 - 左上角重叠部分 + 当前元素值
                 */
                preSum[i][j] = preSum[i-1][j]    // 上方矩形和 (0,0)到(i-2,j-1)
                            + preSum[i][j-1]    // 左边矩形和 (0,0)到(i-1,j-2)
                            + matrix[i-1][j-1]  // 当前元素值
                            - preSum[i-1][j-1]; // 减去重复计算的左上角部分
            }
        }
    }
```
### 蛇形矩阵
给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵
>核心:使用一个坐标进行位移,类似于操纵杆

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int res[100][100];
int main()
{
    int n,m;
    cin>>n>>m;
    int dx[]={0,1,0,-1},dy[]={1,0,-1,0};//操作杆部分
    for(int x=0,y=0,d=0,k=1;k<=n*m;k++)
    {
        res[x][y] = k;
        int a = x+dx[d], b = y + dy[d];
        if(a<0||a>=n||b<0||b>=m||res[a][b])//在未满足条件时,默认向前
        {
            d=(d+1)%4;
            a = x+dx[d], b = y + dy[d];
        }
        x=a,y=b;
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            cout << res[i][j] <<' ';
        }
        cout<<endl;
    }
    cout<<endl;
    return 0;
}
```

## 链表
>用离散的内存储存相关联的数据
### 链表的基本结构
一般的单链表
<img width="1118" height="360" alt="68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139343532393831352e706e67" src="https://github.com/user-attachments/assets/91026684-1325-421f-9098-3f97607219ac" />
```cpp
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数,便于增加新链表
};
```

### 链表的基本操作
#### 删除结点
<img width="1132" height="308" alt="68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139353131343534312d32303233303331303132313435393235372e706e67" src="https://github.com/user-attachments/assets/7c5add50-9007-4e6e-bdfb-0810a38e451f" />

>跳过该结点,使上一个结点直接指向后一个结点,最好把其内存释放

```c
void deleteNode(ListNode* &head, int target) {
    // 如果链表为空，直接返回
    if (head == nullptr) return;
    
    // 如果要删除的是头节点
    if (head->val == target) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    
    // 查找要删除节点的前一个节点
    ListNode* current = head;
    while (current->next != nullptr && current->next->val != target) {
        current = current->next;
    }
    
    // 如果找到了要删除的节点
    if (current->next != nullptr) {
        ListNode* temp = current->next;
        current->next = temp->next;
        delete temp;
    }
}
```
#### 增加节点
```c
#include <iostream>
using namespace std;

// 链表节点定义
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 链表类
class LinkedList {
private:
    ListNode* head;
    
public:
    // 构造函数
    LinkedList() : head(nullptr) {}
    
    // 在头部添加节点
    void addAtHead(int value) {
        ListNode* newNode = new ListNode(value);
        newNode->next = head;
        head = newNode;
    }
    
    // 在尾部添加节点
    void addAtTail(int value) {
        ListNode* newNode = new ListNode(value);
        
        if (head == nullptr) {
            head = newNode;
            return;
        }
        
        ListNode* current = head;
        while (current->next != nullptr) {
            current = current->next;
        }
        current->next = newNode;
    }
    
    // 在指定位置添加节点
    void addAtIndex(int index, int value) {
        if (index == 0) {
            addAtHead(value);
            return;
        }
        
        ListNode* newNode = new ListNode(value);
        ListNode* current = head;
        
        for (int i = 0; i < index - 1 && current != nullptr; i++) {
            current = current->next;
        }
        
        if (current != nullptr) {
            newNode->next = current->next;
            current->next = newNode;
        } else {
            delete newNode;
        }
    }
    
    // 打印链表
    void printList() {
        ListNode* current = head;
        while (current != nullptr) {
            cout << current->val << " -> ";
            current = current->next;
        }
        cout << "nullptr" << endl;
    }
};

// 测试代码
int main() {
    LinkedList list;
    
    // 在尾部添加节点
    list.addAtTail(1);
    list.addAtTail(2);
    list.addAtTail(3);
    cout << "初始链表: ";
    list.printList(); // 输出: 1 -> 2 -> 3 -> nullptr
    
    // 在头部添加节点
    list.addAtHead(0);
    cout << "在头部添加0后: ";
    list.printList(); // 输出: 0 -> 1 -> 2 -> 3 -> nullptr
    
    // 在指定位置添加节点
    list.addAtIndex(2, 10);
    cout << "在位置2添加10后: ";
    list.printList(); // 输出: 0 -> 1 -> 10 -> 2 -> 3 -> nullptr
    
    return 0;
}
```
### 双链表
```c
//采用循环虚拟结点的双链表实现
class MyLinkedList {
public:
    // 定义双向链表节点结构体
    struct DList {
        int elem; // 节点存储的元素
        DList *next; // 指向下一个节点的指针
        DList *prev; // 指向上一个节点的指针
        // 构造函数，创建一个值为elem的新节点
        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {};
    };

    // 构造函数，初始化链表
    MyLinkedList() {
        sentinelNode = new DList(0); // 创建哨兵节点，不存储有效数据
        sentinelNode->next = sentinelNode; // 哨兵节点的下一个节点指向自身，形成循环
        sentinelNode->prev = sentinelNode; // 哨兵节点的上一个节点指向自身，形成循环
        size = 0; // 初始化链表大小为0
    }
```
#### 获取链表中第index个节点的值
```c
    int get(int index) {
        if (index > (size - 1) || index < 0) { // 检查索引是否超出范围
            return -1; // 如果超出范围，返回-1
        }
        int num;
        int mid = size >> 1; // 计算链表中部位置
        DList *curNode = sentinelNode; // 从哨兵节点开始
        if (index < mid) { // 如果索引小于中部位置，从前往后遍历
            for (int i = 0; i < index + 1; i++) {
                curNode = curNode->next; // 移动到目标节点
            }
        } else { // 如果索引大于等于中部位置，从后往前遍历
            for (int i = 0; i < size - index; i++) {
                curNode = curNode->prev; // 移动到目标节点
            }
        }
        num = curNode->elem; // 获取目标节点的值
        return num; // 返回节点的值
    }
```
#### 添加节点
```c
    // 在链表头部添加节点
    void addAtHead(int val) {
        DList *newNode = new DList(val); // 创建新节点
        DList *next = sentinelNode->next; // 获取当前头节点的下一个节点
        newNode->prev = sentinelNode; // 新节点的上一个节点指向哨兵节点
        newNode->next = next; // 新节点的下一个节点指向原来的头节点
        size++; // 链表大小加1
        sentinelNode->next = newNode; // 哨兵节点的下一个节点指向新节点
        next->prev = newNode; // 原来的头节点的上一个节点指向新节点
    }

    // 在链表尾部添加节点
    void addAtTail(int val) {
        DList *newNode = new DList(val); // 创建新节点
        DList *prev = sentinelNode->prev; // 获取当前尾节点的上一个节点
        newNode->next = sentinelNode; // 新节点的下一个节点指向哨兵节点
        newNode->prev = prev; // 新节点的上一个节点指向原来的尾节点
        size++; // 链表大小加1
        sentinelNode->prev = newNode; // 哨兵节点的上一个节点指向新节点
        prev->next = newNode; // 原来的尾节点的下一个节点指向新节点
    }

    // 在链表中的第index个节点之前添加值为val的节点
    void addAtIndex(int index, int val) {
        if (index > size) { // 检查索引是否超出范围
            return; // 如果超出范围，直接返回
        }
        if (index <= 0) { // 如果索引为0或负数，在头部添加节点
            addAtHead(val);
            return;
        }
        int num;
        int mid = size >> 1; // 计算链表中部位置
        DList *curNode = sentinelNode; // 从哨兵节点开始
        if (index < mid) { // 如果索引小于中部位置，从前往后遍历
            for (int i = 0; i < index; i++) {
                curNode = curNode->next; // 移动到目标位置的前一个节点
            }
            DList *temp = curNode->next; // 获取目标位置的节点
            DList *newNode = new DList(val); // 创建新节点
            curNode->next = newNode; // 在目标位置前添加新节点
            temp->prev = newNode; // 目标位置的节点的前一个节点指向新节点
            newNode->next = temp; // 新节点的下一个节点指向目标位置的结点
            newNode->prev = curNode; // 新节点的上一个节点指向当前节点
        } else { // 如果索引大于等于中部位置，从后往前遍历
            for (int i = 0; i < size - index; i++) {
                curNode = curNode->prev; // 移动到目标位置的后一个节点
            }
            DList *temp = curNode->prev; // 获取目标位置的节点
            DList *newNode = new DList(val); // 创建新节点
            curNode->prev = newNode; // 在目标位置后添加新节点
            temp->next = newNode; // 目标位置的节点的下一个节点指向新节点
            newNode->prev = temp; // 新节点的上一个节点指向目标位置的节点
            newNode->next = curNode; // 新节点的下一个节点指向当前节点
        }
        size++; // 链表大小加1
    }
```
#### 删除节点
```c
    // 删除链表中的第index个节点
    void deleteAtIndex(int index) {
        if (index > (size - 1) || index < 0) { // 检查索引是否超出范围
            return; // 如果超出范围，直接返回
        }
        int num;
        int mid = size >> 1; // 计算链表中部位置
        DList *curNode = sentinelNode; // 从哨兵节点开始
        if (index < mid) { // 如果索引小于中部位置，从前往后遍历
            for (int i = 0; i < index; i++) {
                curNode = curNode->next; // 移动到目标位置的前一个节点
            }
            DList *next = curNode->next->next; // 获取目标位置的下一个节点
            curNode->next = next; // 删除目标位置的节点
            next->prev = curNode; // 目标位置的下一个节点的前一个节点指向当前节点
        } else { // 如果索引大于等于中部位置，从后往前遍历
            for (int i = 0; i < size - index - 1; i++) {
                curNode = curNode->prev; // 移动到目标位置的后一个节点
            }
            DList *prev = curNode->prev->prev; // 获取目标位置的下一个节点
            curNode->prev = prev; // 删除目标位置的节点
            prev->next = curNode; // 目标位置的下一个节点的下一个节点指向当前节点
        }
        size--; // 链表大小减1
    }

private:
    int size; // 链表的大小
    DList *sentinelNode; // 哨兵节点的指针
};
```
### 链表的翻转
```c
class Solution{
public:
    Listcode* reverselist(Listcode* head){
        Listcode* temp;
        Listcode* cur=head;
        Listcode* pre=NULL;

        while (cur)}
            temp=cur->next;
            cur->next=pre;
            pre=cur;
            cur=temp;
        }

        return pre;
    }

}
```
### 交换相邻节点
```c
class Solution{
public;
    Listcode* swapPairs(Listcode* head){
        Listcode* dummyhead=new Listcode(0);//利用构造函数定义虚拟头节点
        Listcode->next=Listcode* head;//虚拟头节点指向真正的头节点
        Listcode* cur=dummyhead;//定义指针

        while(cur->next!=nullptr&&&cur->next->next!=nullptr){
            Listcode* tmp=cur->next;
            Listcode* tmp1=cur->next->next->next;

            cur->next=cur->next->next;
            cur->next->next=tmp;
            tmp->next=tmp1;

            cur=cur->next->next;
            }
       Listcode* result=dummyhead->next;
       delete dummyhead;
       return result;
       }
}
```
### 实际例题
#### 删除链表倒数第n个节点
>如何实现找到倒数第n个节点?
>通过快慢指针,让快指针先移动n个节点长度,在同时移动快慢指针知道快指针指向NULL
**要删除倒数第n个节点,慢指针要位于倒数n+1个,所以快指针要多走一个节点**
```c
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        while(n-- && fast != NULL) {
            fast = fast->next;
        }
        fast = fast->next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点
        while (fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next; 
        
        // ListNode *tmp = slow->next;  C++释放内存的逻辑
        // slow->next = tmp->next;
        // delete tmp;
        
        return dummyHead->next;
    }
};
```
#### 判断链表相交
>思路:定义两个指针指向两个链表,判断存不存在相同情况
#### 判断环形链表
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null
>如何判断是否有结点?
>_通过快慢指针的追及问题,若存在环状,会出现快指针转过n圈后追上慢指针的情况_
>如何判断环的入口?
>_通过追及问题中的时间相同列等式,可求得相遇点距离入口的长度等于起点到入口的长度_
<img width="742" height="263" alt="68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303232303932353130333433332e706e67" src="https://github.com/user-attachments/assets/ce58e1f6-8a6a-4d69-bab0-203bbd538a18" />


```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇
            if (slow == fast) {
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2; // 返回环的入口
            }
        }
        return NULL;
    }
};
```
>**特别注意点**

>为什么快指针和慢指针速度是2和1?

>_保证相对速度是1,从而不会出现快指针越过慢指针的情况_

>为什么满指针第一圈就会和快指针相遇?

>_慢指针进入环形链表走一圈,快指针走两圈,相对速度是一圈,一定会相遇_

## 哈希表
### 哈希表的定义
>哈希表是根据关键码的值而直接进行访问的数据结构
eg.数组就是一种简单的哈希表,下标就是其关键码
### 哈希表的用途
**一般用来判断一个元素是否出现在集合中**,使时间复杂度从O(n)变为O(1)
### 哈希函数
构造函数将已有值映射到哈希表中
步骤:
1.将已有的字符转化为hashcode
2.把hashcode通过哈希函数映射到哈希表中
>为防止hashcode中的值大于tablesize,进行取模操作
### 哈希碰撞
当已知量大于tablesize时,会出现多个量映射到同一个哈希表位置中
#### 解决方法
1.拉链法:将相同位置上的元素储存到链表中
2.线性探测法:当tablesize>datasize时,可以放在多于位置
### 常见的三种哈希结构
*数组
*set
*map
###例题
**哈希法:当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。**
1.给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词
>用哈希数组来记录每个字母出现的次数 record[s[i]-'a']++
```c
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for (int i = 0; i < s.size(); i++) {
            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
            record[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                return false;
            }
        }
        // record数组所有元素都为零0，说明字符串s和t是字母异位词
        return true;
    }
};
```
2.给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案
```c
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> result;
        if (A.size() == 0) return result;
        int hash[26] = {0}; // 用来统计所有字符串里字符出现的最小频率
        for (int i = 0; i < A[0].size(); i++) { // 用第一个字符串给hash初始化
            hash[A[0][i] - 'a']++;
        }

        int hashOtherStr[26] = {0}; // 统计除第一个字符串外字符的出现频率
        for (int i = 1; i < A.size(); i++) {
            memset(hashOtherStr, 0, 26 * sizeof(int));//将数组中的值(这里memset针对的是字节)全部初始化成0
            for (int j = 0; j < A[i].size(); j++) {
                hashOtherStr[A[i][j] - 'a']++;
            }
            // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数
            for (int k = 0; k < 26; k++) {
                hash[k] = min(hash[k], hashOtherStr[k]);
            }
        }
        // 将hash统计的字符次数，转成输出形式
        for (int i = 0; i < 26; i++) {
            while (hash[i] != 0) { // 注意这里是while，多个重复的字符
                string s(1, i + 'a'); // 1代表一个,i+'a'将int转化为string
                result.push_back(s);
                hash[i]--;
            }
        }

        return result;
    }
};
```
3.编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。
>如果不为快乐数,各位数的平方和肯定为循环数组
```c
class Solution {
public:
    // 取数值各个位上的单数之和
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1) {
            int sum = getSum(n);
            if (sum == 1) {
                return true;
            }
            // 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
            if (set.find(sum) != set.end()) //.find和.end函数返回的是迭代器.find返回set末尾下一个空迭代器,当该值在set中不存在时,返回.find
                return false;
            } else {
                set.insert(sum);
            }
            n = sum;
        }
    }
};
```
4.给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍
>因为本题，我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适
```c
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); //迭代器相等的判断依据是指向的地址相同,因为map中没有重复值,所以也可以认为是key值相等迭代器相等
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```



        
