# 代码入门
## 数组相关
### 整数二分
>考虑好边界情况
```c
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
### 蛇形矩阵
给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵
>核心:使用一个坐标进行位移,类似于操纵杆

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int res[100][100];
int main()
{
    int n,m;
    cin>>n>>m;
    int dx[]={0,1,0,-1},dy[]={1,0,-1,0};//操作杆部分
    for(int x=0,y=0,d=0,k=1;k<=n*m;k++)
    {
        res[x][y] = k;
        int a = x+dx[d], b = y + dy[d];
        if(a<0||a>=n||b<0||b>=m||res[a][b])//在未满足条件时,默认向前
        {
            d=(d+1)%4;
            a = x+dx[d], b = y + dy[d];
        }
        x=a,y=b;
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            cout << res[i][j] <<' ';
        }
        cout<<endl;
    }
    cout<<endl;
    return 0;
}
```

## 链表
>用离散的内存储存相关联的数据
### 链表的基本结构
一般的单链表
<img width="1118" height="360" alt="68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139343532393831352e706e67" src="https://github.com/user-attachments/assets/91026684-1325-421f-9098-3f97607219ac" />
```cpp
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数,便于增加新链表
};
```

### 链表的基本操作
#### 删除结点
<img width="1132" height="308" alt="68747470733a2f2f66696c65312e6b616d61636f6465722e636f6d2f692f616c676f2f32303230303830363139353131343534312d32303233303331303132313435393235372e706e67" src="https://github.com/user-attachments/assets/7c5add50-9007-4e6e-bdfb-0810a38e451f" />
>跳过该结点,使上一个结点直接指向后一个结点,最好把其内存释放

```c
void deleteNode(ListNode* &head, int target) {
    // 如果链表为空，直接返回
    if (head == nullptr) return;
    
    // 如果要删除的是头节点
    if (head->val == target) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    
    // 查找要删除节点的前一个节点
    ListNode* current = head;
    while (current->next != nullptr && current->next->val != target) {
        current = current->next;
    }
    
    // 如果找到了要删除的节点
    if (current->next != nullptr) {
        ListNode* temp = current->next;
        current->next = temp->next;
        delete temp;
    }
}
```
#### 增加节点
```c
#include <iostream>
using namespace std;

// 链表节点定义
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 链表类
class LinkedList {
private:
    ListNode* head;
    
public:
    // 构造函数
    LinkedList() : head(nullptr) {}
    
    // 在头部添加节点
    void addAtHead(int value) {
        ListNode* newNode = new ListNode(value);
        newNode->next = head;
        head = newNode;
    }
    
    // 在尾部添加节点
    void addAtTail(int value) {
        ListNode* newNode = new ListNode(value);
        
        if (head == nullptr) {
            head = newNode;
            return;
        }
        
        ListNode* current = head;
        while (current->next != nullptr) {
            current = current->next;
        }
        current->next = newNode;
    }
    
    // 在指定位置添加节点
    void addAtIndex(int index, int value) {
        if (index == 0) {
            addAtHead(value);
            return;
        }
        
        ListNode* newNode = new ListNode(value);
        ListNode* current = head;
        
        for (int i = 0; i < index - 1 && current != nullptr; i++) {
            current = current->next;
        }
        
        if (current != nullptr) {
            newNode->next = current->next;
            current->next = newNode;
        } else {
            delete newNode;
        }
    }
    
    // 打印链表
    void printList() {
        ListNode* current = head;
        while (current != nullptr) {
            cout << current->val << " -> ";
            current = current->next;
        }
        cout << "nullptr" << endl;
    }
};

// 测试代码
int main() {
    LinkedList list;
    
    // 在尾部添加节点
    list.addAtTail(1);
    list.addAtTail(2);
    list.addAtTail(3);
    cout << "初始链表: ";
    list.printList(); // 输出: 1 -> 2 -> 3 -> nullptr
    
    // 在头部添加节点
    list.addAtHead(0);
    cout << "在头部添加0后: ";
    list.printList(); // 输出: 0 -> 1 -> 2 -> 3 -> nullptr
    
    // 在指定位置添加节点
    list.addAtIndex(2, 10);
    cout << "在位置2添加10后: ";
    list.printList(); // 输出: 0 -> 1 -> 10 -> 2 -> 3 -> nullptr
    
    return 0;
}
```
### 双链表
```c
//采用循环虚拟结点的双链表实现
class MyLinkedList {
public:
    // 定义双向链表节点结构体
    struct DList {
        int elem; // 节点存储的元素
        DList *next; // 指向下一个节点的指针
        DList *prev; // 指向上一个节点的指针
        // 构造函数，创建一个值为elem的新节点
        DList(int elem) : elem(elem), next(nullptr), prev(nullptr) {};
    };

    // 构造函数，初始化链表
    MyLinkedList() {
        sentinelNode = new DList(0); // 创建哨兵节点，不存储有效数据
        sentinelNode->next = sentinelNode; // 哨兵节点的下一个节点指向自身，形成循环
        sentinelNode->prev = sentinelNode; // 哨兵节点的上一个节点指向自身，形成循环
        size = 0; // 初始化链表大小为0
    }
```
#### 获取链表中第index个节点的值
```c
    int get(int index) {
        if (index > (size - 1) || index < 0) { // 检查索引是否超出范围
            return -1; // 如果超出范围，返回-1
        }
        int num;
        int mid = size >> 1; // 计算链表中部位置
        DList *curNode = sentinelNode; // 从哨兵节点开始
        if (index < mid) { // 如果索引小于中部位置，从前往后遍历
            for (int i = 0; i < index + 1; i++) {
                curNode = curNode->next; // 移动到目标节点
            }
        } else { // 如果索引大于等于中部位置，从后往前遍历
            for (int i = 0; i < size - index; i++) {
                curNode = curNode->prev; // 移动到目标节点
            }
        }
        num = curNode->elem; // 获取目标节点的值
        return num; // 返回节点的值
    }
```
#### 添加节点
```c
    // 在链表头部添加节点
    void addAtHead(int val) {
        DList *newNode = new DList(val); // 创建新节点
        DList *next = sentinelNode->next; // 获取当前头节点的下一个节点
        newNode->prev = sentinelNode; // 新节点的上一个节点指向哨兵节点
        newNode->next = next; // 新节点的下一个节点指向原来的头节点
        size++; // 链表大小加1
        sentinelNode->next = newNode; // 哨兵节点的下一个节点指向新节点
        next->prev = newNode; // 原来的头节点的上一个节点指向新节点
    }

    // 在链表尾部添加节点
    void addAtTail(int val) {
        DList *newNode = new DList(val); // 创建新节点
        DList *prev = sentinelNode->prev; // 获取当前尾节点的上一个节点
        newNode->next = sentinelNode; // 新节点的下一个节点指向哨兵节点
        newNode->prev = prev; // 新节点的上一个节点指向原来的尾节点
        size++; // 链表大小加1
        sentinelNode->prev = newNode; // 哨兵节点的上一个节点指向新节点
        prev->next = newNode; // 原来的尾节点的下一个节点指向新节点
    }

    // 在链表中的第index个节点之前添加值为val的节点
    void addAtIndex(int index, int val) {
        if (index > size) { // 检查索引是否超出范围
            return; // 如果超出范围，直接返回
        }
        if (index <= 0) { // 如果索引为0或负数，在头部添加节点
            addAtHead(val);
            return;
        }
        int num;
        int mid = size >> 1; // 计算链表中部位置
        DList *curNode = sentinelNode; // 从哨兵节点开始
        if (index < mid) { // 如果索引小于中部位置，从前往后遍历
            for (int i = 0; i < index; i++) {
                curNode = curNode->next; // 移动到目标位置的前一个节点
            }
            DList *temp = curNode->next; // 获取目标位置的节点
            DList *newNode = new DList(val); // 创建新节点
            curNode->next = newNode; // 在目标位置前添加新节点
            temp->prev = newNode; // 目标位置的节点的前一个节点指向新节点
            newNode->next = temp; // 新节点的下一个节点指向目标位置的结点
            newNode->prev = curNode; // 新节点的上一个节点指向当前节点
        } else { // 如果索引大于等于中部位置，从后往前遍历
            for (int i = 0; i < size - index; i++) {
                curNode = curNode->prev; // 移动到目标位置的后一个节点
            }
            DList *temp = curNode->prev; // 获取目标位置的节点
            DList *newNode = new DList(val); // 创建新节点
            curNode->prev = newNode; // 在目标位置后添加新节点
            temp->next = newNode; // 目标位置的节点的下一个节点指向新节点
            newNode->prev = temp; // 新节点的上一个节点指向目标位置的节点
            newNode->next = curNode; // 新节点的下一个节点指向当前节点
        }
        size++; // 链表大小加1
    }
```
删除节点
```c
    // 删除链表中的第index个节点
    void deleteAtIndex(int index) {
        if (index > (size - 1) || index < 0) { // 检查索引是否超出范围
            return; // 如果超出范围，直接返回
        }
        int num;
        int mid = size >> 1; // 计算链表中部位置
        DList *curNode = sentinelNode; // 从哨兵节点开始
        if (index < mid) { // 如果索引小于中部位置，从前往后遍历
            for (int i = 0; i < index; i++) {
                curNode = curNode->next; // 移动到目标位置的前一个节点
            }
            DList *next = curNode->next->next; // 获取目标位置的下一个节点
            curNode->next = next; // 删除目标位置的节点
            next->prev = curNode; // 目标位置的下一个节点的前一个节点指向当前节点
        } else { // 如果索引大于等于中部位置，从后往前遍历
            for (int i = 0; i < size - index - 1; i++) {
                curNode = curNode->prev; // 移动到目标位置的后一个节点
            }
            DList *prev = curNode->prev->prev; // 获取目标位置的下一个节点
            curNode->prev = prev; // 删除目标位置的节点
            prev->next = curNode; // 目标位置的下一个节点的下一个节点指向当前节点
        }
        size--; // 链表大小减1
    }

private:
    int size; // 链表的大小
    DList *sentinelNode; // 哨兵节点的指针
};
```
