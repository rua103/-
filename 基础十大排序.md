# 排序的稳定性
>如果插入元素不会打乱原有已有排序的稳定性,则称这个排序稳定
# 选择排序
>最简单的排序,从第一个元素开始,比较和每个元素的大小,时间复杂度显然是O(n^2)
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    //交换
    int tmp = nums[sortIndex];
    nums[sortIndex] = nums[minIndex];
    nums[minIndex] = tmp;

    sortIndex++;
}
```
>因为选择排序的交换操作,所以选择排序不具有稳定性
>
>eg.{2',2'',2''',1}经过第一次交换后为{1,2'',2''',2'},原本相同元素的顺序被打破

如何解决这一问题?

>因为是交换导致这一问题的出现,所以能不能找到方法代替交换这一操作

>用插入代替排序:找到最小值后,记录下最小值,将指针到最小值的区间整体向后移动一位,再在当前指针处插入最小值
```c
//优化版本
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    int tmp = nums[minIndex];
    while (minIndex > i){
        nums[minIndex] = nums[minIndex-1];//整体后移
        minIndex--;
    }
        nums[i] = tmp;
]
```
# 冒泡排序
>对选择排序的优化,通过交换逆序对(一对前数大于后数的数组),使相同数字的相对位置不会发生改变,从而实现稳定
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
            }
        }

        sortIndex++;
    }
}
```
>与选择排序的优化算法比较,冒泡排序只用了一个两层for循环就实现了稳定排序,包含了逐个后移的过程,虽然都是O(n^2),但效率更高
## 优化写法
从上面两种代码的写法,可以找到一个问题:无论数组是否有序,for循环都会遍历整个数组,大大降低了效率.如果加上一个布尔类型的指示器,使循环在有序的条件下break,可进一步降低时间复杂度.
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        bool swapped = false;
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
                swappped = true;
            }
        }

        if(!swapped) break;
     
        sortIndex++;
    }
}
```
# 插入排序
前两种排序方式都是在现有指针右边寻找最小值而插入排序是在不改变右边顺序的情况下,将现有指针插入已有的顺序数组当中.
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 1;
    while (sortIndex<n){
        for (int i =sortIndex;i >0;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i];
                nums[i]=nums[i-1];
                nums[i-1] = tmp;
            }
            else break;
        }

        sortIndex++;
    }
}
```
>因为break的作用,导致插入排序的时间复杂度会随着原有数据有序性上升而下降,当原有数据完全有序时,插入排序的时间复杂度会退化为O(n),所以插入排序的综合性能要高于冒泡排序.
# 希尔排序
## h有序数组
>一个数组是 h 有序的，是指这个数组中任意间隔为 h（或者说间隔元素的个数为 h-1）的元素都是有序的.
## 基本思路
>基于插入排序,希尔排序通过h的增序函数扩大h的值,进行类插入排序的操作,使数据变得基本有序,再递归减小h,最终使h=1.
## 代码实现
```c
//以增序函数y=2^{x-1}为例
void sort(vector<int>& nums){
    int n = nums.size();
    int h =1;
    while (h<n/2){
        n*=2;
    }

    while (h>=1){
        int sortIndex = h;//从h开始遍历数组
        while (sortIndex<n){
            for (int i = sorIndex;i>=h;i-=h){
                if (nums[i]<nums[i-h]){
                   int tmp = nums [i];
                   nums[i] = nums[i-h];
                   nums [i-h] = tmp;
                }
                else break;
            }

            sortIndex--;
        }

        h/=2;
    }
}
```
# 快速排序

