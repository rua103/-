# 排序的稳定性
>如果插入元素不会打乱原有已有排序的稳定性,则称这个排序稳定
# 选择排序
>最简单的排序,从第一个元素开始,比较和每个元素的大小,时间复杂度显然是O(n^2)
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    //交换
    int tmp = nums[sortIndex];
    nums[sortIndex] = nums[minIndex];
    nums[minIndex] = tmp;

    sortIndex++;
}
```
>因为选择排序的交换操作,所以选择排序不具有稳定性
>
>eg.{2',2'',2''',1}经过第一次交换后为{1,2'',2''',2'},原本相同元素的顺序被打破

如何解决这一问题?

>因为是交换导致这一问题的出现,所以能不能找到方法代替交换这一操作

>用插入代替排序:找到最小值后,记录下最小值,将指针到最小值的区间整体向后移动一位,再在当前指针处插入最小值
```c
//优化版本
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    int tmp = nums[minIndex];
    while (minIndex > i){
        nums[minIndex] = nums[minIndex-1];//整体后移
        minIndex--;
    }
        nums[i] = tmp;
]
```
# 冒泡排序
>对选择排序的优化,通过交换逆序对(一对前数大于后数的数组),使相同数字的相对位置不会发生改变,从而实现稳定
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
            }
        }

        sortIndex++;
    }
}
```
>与选择排序的优化算法比较,冒泡排序只用了一个两层for循环就实现了稳定排序,包含了逐个后移的过程,虽然都是O(n^2),但效率更高
## 优化写法
从上面两种代码的写法,可以找到一个问题:无论数组是否有序,for循环都会遍历整个数组,大大降低了效率.如果加上一个布尔类型的指示器,使循环在有序的条件下break,可进一步降低时间复杂度.
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        bool swapped = false;
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
                swappped = true;
            }
        }

        if(!swapped) break;
     
        sortIndex++;
    }
}
```
# 插入排序
前两种排序方式都是在现有指针右边寻找最小值而插入排序是在不改变右边顺序的情况下,将现有指针插入已有的顺序数组当中.
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 1;
    while (sortIndex<n){
        for (int i =sortIndex;i >0;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i];
                nums[i]=nums[i-1];
                nums[i-1] = tmp;
            }
            else break;
        }

        sortIndex++;
    }
}
```
>因为break的作用,导致插入排序的时间复杂度会随着原有数据有序性上升而下降,当原有数据完全有序时,插入排序的时间复杂度会退化为O(n),所以插入排序的综合性能要高于冒泡排序.
# 希尔排序
## h有序数组
>一个数组是 h 有序的，是指这个数组中任意间隔为 h（或者说间隔元素的个数为 h-1）的元素都是有序的.
## 基本思路
>基于插入排序,希尔排序通过h的增序函数扩大h的值,进行类插入排序的操作,使数据变得基本有序,再递归减小h,最终使h=1.
## 代码实现
```c
//以增序函数y=2^{x-1}为例
void sort(vector<int>& nums){
    int n = nums.size();
    int h =1;
    while (h<n/2){
        n*=2;
    }

    while (h>=1){
        int sortIndex = h;//从h开始遍历数组
        while (sortIndex<n){
            for (int i = sorIndex;i>=h;i-=h){
                if (nums[i]<nums[i-h]){
                   int tmp = nums [i];
                   nums[i] = nums[i-h];
                   nums [i-h] = tmp;
                }
                else break;
            }

            sortIndex--;
        }

        h/=2;
    }
}
```
# 快速排序
## 基本思路
>先将一个数排好序,再以它为左右起点拍好剩下的数,相当于构造二叉搜索树,利用他的前序遍历
## 代码实现
```c
class Quick{
public:
    void sort(vector<int>& nums){
        shuffle(nums);
        sort(nums,0,nums.siez()-1)
    }

private:
    void sort(vector<int>& nums,in lo,int hi){
        if (lo >= hi){
            return 0;
        }

        int p = partition(nums,lo,hi);

        sort (nums,lo,p-1);
        sort (nums,p+1,hi);
    }

    int partition(vector<int>&nums, int lo , int hi){
        int pivot = nums[lo];
        int i = lo + 1 ,j = hi;
        while (i<= j){
            while (i < hi && nums[i] <= pivot){
                i++;
            }
            while (j>lo && nums[j]>= pivot) j--;

            if (i >= j) break;

            swap(nums[i],nums[j]);       
        }
        swap (nums[lo],nums[j]);

        return j;
    }
    void shuffle(vector<int>& nums){
        mt19937 gen;
        int n = nums.size();
        for (int i = 0; i<n ;i++){
            int r = i + gen()%(n-i);
            swap (nums[i],nums[r]);
        }
    }

    void swap(int i, int j){
        int tmp = j;
        j = i;
        i = tmp;
    }
}
```
>当极度倒霉时,快速排序会退化为选择排序,所以使用洗牌算法把数据打乱,尽可能降低时间复杂度
# 归并排序
```c
class Merge {

private:
    // 用于辅助合并有序数组
    static vector<int> temp;
    
public:
    static void sort(vector<int>& nums) {
        // 先给辅助数组开辟内存空间
        temp.resize(nums.size());
        // 排序整个数组（原地修改）
        sort(nums, 0, nums.size() - 1);
    }

private:
    // 定义：将子数组 nums[lo..hi] 进行排序
    static void sort(vector<int>& nums, int lo, int hi) {
        if (lo == hi) {
            // 单个元素不用排序
            return;
        }
        // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2
        int mid = lo + (hi - lo) / 2;
        // 先对左半部分数组 nums[lo..mid] 排序
        sort(nums, lo, mid);
        // 再对右半部分数组 nums[mid+1..hi] 排序
        sort(nums, mid + 1, hi);
        // 将两部分有序数组合并成一个有序数组
        merge(nums, lo, mid, hi);
    }

    static void merge(vector<int>& nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }

        // 数组双指针技巧，合并两个有序数组
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                // 左半边数组已全部被合并
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                // 右半边数组已全部被合并
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }
};

// 在类外部定义并初始化静态变量 temp
vector<int> Merge::temp;
```
# 堆排序
>基于二叉堆的优先级队列的实现原理,直接在原有数组进行swim,sink操作
```c
//这里使用大顶堆,直接将堆顶删除的元素加入到数组末尾
int parent(int node) {
    return (node - 1) / 2;
}

// 左子节点的索引
int left(int node) {
    return node * 2 + 1;
}

// 右子节点的索引
int right(int node) {
    return node * 2 + 2;
}

// 交换数组中两个元素的位置
void swap(std::vector<int>& heap, int i, int j) {
    int temp = heap[i];
    heap[i] = heap[j];
    heap[j] = temp;
}


void maxHeapSwim(std::vector<int>& heap, int node) {
    while (node > 0 && heap[parent(node)] < heap[node]) {
        swap(heap, parent(node), node);
        node = parent(node);
    }
}

void maxHeapSink(std::vector<int>& heap, int node, int size) {
    while (left(node) < size || right(node) < size) {
        // 小顶堆和大顶堆的唯一区别就在这里，比较逻辑相反
        // 比较自己和左右子节点，看看谁最大
        int max = node;
        if (left(node) < size && heap[left(node)] > heap[max]) {
            max = left(node);
        }
        if (right(node) < size && heap[right(node)] > heap[max]) {
            max = right(node);
        }
        if (max == node) {
            break;
        }
        swap(heap, node, max);
        node = max;
    }
}

// 将输入的数组元素从小到大排序
void sort(vector<int>& nums) {
    // 第一步，原地建堆，注意这里创建的是大顶堆
    // 从最后一个非叶子节点开始，依次构造二叉堆
    int n = nums.size();
    for (int i =  n / 2 - 1; i >= 0; i--) {
        maxHeapSink(nums, i, n);
        //相当于完成了一个递归过程
    }

    // 合并完成，现在整个数组已经是一个大顶堆

    // 第二步，排序，和刚才的代码一样
    int heapSize = n;
    while (heapSize > 0) {
        // 从堆顶删除元素，放到堆的后面
        swap(nums, 0, heapSize - 1);
        heapSize--;
        // 恢复堆的性质
        maxHeapSink(nums, 0, heapSize);
        // 现在 nums[0..heapSize) 是一个大顶堆，nums[heapSize..) 是有序元素
    }

```
# 计数排序
>记载每个数据出现的次数,根据前缀和排序
```c
void sort (vector<int> nums){
    int min = INT_MAX;
    int max = INT_MIN;
    for (int num : nums){
        min = std::min(min,num);
        max = std::max(max,num);
    }

    int offset = -min;
    vector<int> count(max-min+1,0);

    for (int num ; nums){
        count[num = offset]++;
    }

    for (int i = 1;i< count.size();i++){
        count[i] += count[i-1];
    }

    vector<int> sorted(nums.size());
    for (int i = nums.size() - 1 ;i --)
        sorted[count[nums[i]+offset] - 1] = nums[i];
        count[nums[i] + offset]--;

    for (int i = 0 ; i<nums.size(); i++)
    nums[i] = sorted [i];
}
```
# 桶排序
```c
void bucketSort(vector<int>& nums,int BucketCount){
    bool sorted = true;
    for (int i = 1;i<nums.size();i++){
        if (nums[i] < nums[i-1]){
            sorted = false;
            break;
        }
    }

    if (sorted) return;

    int min = INT_MAX;
    int max = INT_MIN;
    for ( int num : nums){
        min = std::min(min,num);
        max = std::max(max,num)
    }

    int offset = -min;

    int BucketSize = (max - min)/BucketCount + 1;

    vector<int> (buckets, lBUcketsize,0);

    for (int num : nums){
        int index = (num+offset)/bucketSize;
        buckets[index].add(num);
    }

    for (int i = 0;i < BucketSize;i++){
        Bucketsort(buckets[i],BucketCount);
    }

    int index = 0;
    for (int i = 0; i<BucketCount;i++){
        for (int num : bucket[i]){
            nums[index++] = num;
        }
    }
}
```
# 基数排序
```c
// 基数排序
void radixSortLSD(std::vector<int>& nums) {
    int min = INT_MAX;
    for (int num : nums) {
        min = std::min(min, num);
    }

    // 根据最小元素，将所有元素转化为从零开始的非负数
    int offset = -min;
    for (int i = 0; i < nums.size(); i++) {
        nums[i] += offset;
    }

    int max = INT_MIN;
    for (int num : nums) {
        max = std::max(max, num);
    }

    // 计算最大元素的位数
    int maxLen = 0;
    while (max > 0) {
        max /= 10;
        maxLen++;
    }

    // 从低位到高位，依次对每一位进行计数排序
    for (int k = 0; k < maxLen; k++) {
        countSort(nums, k);
    }

    // 将所有元素转化回原来的值
    for (int i = 0; i < nums.size(); i++) {
        nums[i] -= offset;
    }
}

// 基数排序使用的计数排序算法函数
// 已经确保 nums 中的元素都是非负数
// k 是当前需要排序的位数
void countSort(std::vector<int>& nums, int k) {
    // 基数排序中每一位十进制数的取值范围是 0~9
    std::vector<int> count(10, 0);

    // 对每个元素的第 k 位进行计数
    for (int num : nums) {
        int digit = (num / static_cast<int>(std::pow(10, k))) % 10;
        count[digit]++;
    }

    for (int i = 1; i < count.size(); i++) {
        count[i] += count[i - 1];
    }

    // 按照第 k 位的值对元素进行排序
    std::vector<int> sorted(nums.size());
    for (int i = nums.size() - 1; i >= 0; i--) {
        int digit = (nums[i] / static_cast<int>(std::pow(10, k))) % 10;
        sorted[count[digit] - 1] = nums[i];
        count[digit]--;
    }

    // 把排序结果复制回原数组
    for (int i = 0; i < nums.size(); i++) {
        nums[i] = sorted[i];
    }
}
```
