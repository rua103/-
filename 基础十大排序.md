# 排序的稳定性
>如果插入元素不会打乱原有已有排序的稳定性,则称这个排序稳定
# 选择排序
>最简单的排序,从第一个元素开始,比较和每个元素的大小,时间复杂度显然是O(n^2)
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    //交换
    int tmp = nums[sortIndex];
    nums[sortIndex] = nums[minIndex];
    nums[minIndex] = tmp;

    sortIndex++;
}
```
>因为选择排序的交换操作,所以选择排序不具有稳定性
>
>eg.{2',2'',2''',1}经过第一次交换后为{1,2'',2''',2'},原本相同元素的顺序被打破

如何解决这一问题?

>因为是交换导致这一问题的出现,所以能不能找到方法代替交换这一操作

>用插入代替排序:找到最小值后,记录下最小值,将指针到最小值的区间整体向后移动一位,再在当前指针处插入最小值
```c
//优化版本
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    int tmp = nums[minIndex];
    while (minIndex > i){
        nums[minIndex] = nums[minIndex-1];//整体后移
        minIndex--;
    }
        nums[i] = tmp;
]
```
# 冒泡排序
>对选择排序的优化,通过交换逆序对(一对前数大于后数的数组),使相同数字的相对位置不会发生改变,从而实现稳定
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
            }
        }

        sortIndex++;
    }
}
```
>与选择排序的优化算法比较,冒泡排序只用了一个两层for循环就实现了稳定排序,包含了逐个后移的过程,虽然都是O(n^2),但效率更高
## 优化写法
从上面两种代码的写法,可以找到一个问题:无论数组是否有序,for循环都会遍历整个数组,大大降低了效率.如果加上一个布尔类型的指示器,使循环在有序的条件下break,可进一步降低时间复杂度.
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        bool swapped = false;
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
                swappped = true;
            }
        }

        if(!swapped) break;
     
        sortIndex++;
    }
}
```
# 插入排序
前两种排序方式都是在现有指针右边寻找最小值而插入排序是在不改变右边顺序的情况下,将现有指针插入已有的顺序数组当中.
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 1;
    while (sortIndex<n){
        for (int i =sortIndex;i >0;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i];
                nums[i]=nums[i-1];
                nums[i-1] = tmp;
            }
            else break;
        }

        sortIndex++;
    }
}
```
>因为break的作用,导致插入排序的时间复杂度会随着原有数据有序性上升而下降,当原有数据完全有序时,插入排序的时间复杂度会退化为O(n),所以插入排序的综合性能要高于冒泡排序.
# 希尔排序
## h有序数组
>一个数组是 h 有序的，是指这个数组中任意间隔为 h（或者说间隔元素的个数为 h-1）的元素都是有序的.
## 基本思路
>基于插入排序,希尔排序通过h的增序函数扩大h的值,进行类插入排序的操作,使数据变得基本有序,再递归减小h,最终使h=1.
## 代码实现
```c
//以增序函数y=2^{x-1}为例
void sort(vector<int>& nums){
    int n = nums.size();
    int h =1;
    while (h<n/2){
        n*=2;
    }

    while (h>=1){
        int sortIndex = h;//从h开始遍历数组
        while (sortIndex<n){
            for (int i = sorIndex;i>=h;i-=h){
                if (nums[i]<nums[i-h]){
                   int tmp = nums [i];
                   nums[i] = nums[i-h];
                   nums [i-h] = tmp;
                }
                else break;
            }

            sortIndex--;
        }

        h/=2;
    }
}
```
# 快速排序
## 基本思路
>先将一个数排好序,再以它为左右起点拍好剩下的数,相当于构造二叉搜索树,利用他的前序遍历
## 代码实现
```c
class Quick{
public:
    void sort(vector<int>& nums){
        shuffle(nums);
        sort(nums,0,nums.siez()-1)
    }

private:
    void sort(vector<int>& nums,in lo,int hi){
        if (lo >= hi){
            return 0;
        }

        int p = partition(nums,lo,hi);

        sort (nums,lo,p-1);
        sort (nums,p+1,hi);
    }

    int partition(vector<int>&nums, int lo , int hi){
        int pivot = nums[lo];
        int i = lo + 1 ,j = hi;
        while (i<= j){
            while (i < hi && nums[i] <= pivot){
                i++;
            }
            while (j>lo && nums[j]>= pivot) j--;

            if (i >= j) break;

            swap(nums[i],nums[j]);       
        }
        swap (nums[lo],nums[j]);

        return j;
    }
    void shuffle(vector<int>& nums){
        mt19937 gen;
        int n = nums.size();
        for (int i = 0; i<n ;i++){
            int r = i + gen()%(n-i);
            swap (nums[i],nums[r]);
        }
    }

    void swap(int i, int j){
        int tmp = j;
        j = i;
        i = tmp;
    }
}
```
>当极度倒霉时,快速排序会退化为选择排序,所以使用洗牌算法把数据打乱,尽可能降低时间复杂度
# 归并排序
```c
class Merge {

private:
    // 用于辅助合并有序数组
    static vector<int> temp;
    
public:
    static void sort(vector<int>& nums) {
        // 先给辅助数组开辟内存空间
        temp.resize(nums.size());
        // 排序整个数组（原地修改）
        sort(nums, 0, nums.size() - 1);
    }

private:
    // 定义：将子数组 nums[lo..hi] 进行排序
    static void sort(vector<int>& nums, int lo, int hi) {
        if (lo == hi) {
            // 单个元素不用排序
            return;
        }
        // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2
        int mid = lo + (hi - lo) / 2;
        // 先对左半部分数组 nums[lo..mid] 排序
        sort(nums, lo, mid);
        // 再对右半部分数组 nums[mid+1..hi] 排序
        sort(nums, mid + 1, hi);
        // 将两部分有序数组合并成一个有序数组
        merge(nums, lo, mid, hi);
    }

    // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组
    static void merge(vector<int>& nums, int lo, int mid, int hi) {
        // 先把 nums[lo..hi] 复制到辅助数组中
        // 以便合并后的结果能够直接存入 nums
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }

        // 数组双指针技巧，合并两个有序数组
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                // 左半边数组已全部被合并
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                // 右半边数组已全部被合并
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }
};

// 在类外部定义并初始化静态变量 temp
vector<int> Merge::temp;
```
