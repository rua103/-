# 排序的稳定性
>如果插入元素不会打乱原有已有排序的稳定性,则称这个排序稳定
# 选择排序
>最简单的排序,从第一个元素开始,比较和每个元素的大小,时间复杂度显然是O(n^2)
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    //交换
    int tmp = nums[sortIndex];
    nums[sortIndex] = nums[minIndex];
    nums[minIndex] = tmp;

    sortIndex++;
}
```
>因为选择排序的交换操作,所以选择排序不具有稳定性
>
>eg.{2',2'',2''',1}经过第一次交换后为{1,2'',2''',2'},原本相同元素的顺序被打破

如何解决这一问题?

>因为是交换导致这一问题的出现,所以能不能找到方法代替交换这一操作

>用插入代替排序:找到最小值后,记录下最小值,将指针到最小值的区间整体向后移动一位,再在当前指针处插入最小值
```c
//优化版本
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex =0;//搜索指针,其右边的元素未被排序
    int minIndex;//最小指针,记录最小值
    while (sortIndex<n)
        minIndex = sortIndex;
        for (i = sortIndex + 1;i<n;i++){
             if (nums[i]<nums[minIndex]){
                 minIndex = i ;
             }
        }
    int tmp = nums[minIndex];
    while (minIndex > i){
        nums[minIndex] = nums[minIndex-1];//整体后移
        minIndex--;
    }
        nums[i] = tmp;
]
```
# 冒泡排序
>对选择排序的优化,通过交换逆序对(一对前数大于后数的数组),使相同数字的相对位置不会发生改变,从而实现稳定
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
            }
        }

        sortIndex++;
    }
}
```
>与选择排序的优化算法比较,冒泡排序只用了一个两层for循环就实现了稳定排序,包含了逐个后移的过程,虽然都是O(n^2),但效率更高
## 优化写法
从上面两种代码的写法,可以找到一个问题:无论数组是否有序,for循环都会遍历整个数组,大大降低了效率.如果加上一个布尔类型的指示器,使循环在有序的条件下break,可进一步降低时间复杂度.
```c
void sort(vector<int>& nums){
    int n = nums.size();
    int sortIndex = 0;
    while (sortIndex < n){
        bool swapped = false;
        for (int i = n-1;i>sortIndex;i--){
            if (nums[i]<nums[i-1]){
                int tmp = nums[i-1];
                nums[i-1] = nums[i];
                nums[i] = tmp;
                swappped = true;
            }
        }

        if(!swapped) break;
     
        sortIndex++;
    }
}
```
# 插入排序
